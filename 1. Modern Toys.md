## 一、现代的玩具
一个 Q 与 A 的对话，展示了 Hello Java World。 

> Q : 5 是整型吗?

> A : 是。

---

> Q : -23 是数吗?

> A : 是，我们一般不用负数。

---

> Q : 5.32 是整数吗?

> A : 不是，我们不用这种类型的数表示 5.32 。

---

> Q : 5 是什么类型的数?

> A : int。<br>
批注: int 是基本类型，Integer 是其包装类。

---

> Q : 快，报出另一个整数！

> A : 19？

---

> Q : true 是什么类型的值？

> A : 布尔。<br>
批注：布尔英文是 boolean。

---

> Q : false 是什么类型的值？

> A : 布尔。<br>

---

> Q : 还有其他布尔值吗？

> A : 没有，布尔值就两个 true 和 false。

---

> Q : int 是什么？

> A : 一种类型。

---

> Q : 布尔 boolean 是什么？

> A : 也是一种类型。

---

> Q : 什么是类型？

> A : 类型是值名称的集合。<br>
批注：类型英文是 type。

---

> Q : 什么是类型？

> A : 有时，我们使用类型来定义一组集合。

---

> Q : 我们能创建新的类型吗？

> A : 我们还不知道怎么创建。<br>
批注：类型创建需要建立语言级别。

---

> Q : 画出下面类的必要关系特征。
```
abstract class Seasoning {}
```
```
class Salt extends Seasoning {}
```
```
class Pepper extends Seasoning {}
```
批注：Seasoning 是数据类型。
> A : 这样画？
![类关系图](https://github.com/JeffLi1993/a-little-java-a-few-pattern/blob/master/image/toys_00.png)

---

> Q : 是的。Seasoning 是数据类型，Salt 和 Pepper 是 Seasoning 的变体。

> A : 好的。三个类全部都是新类型吗？

---

> Q : 是的，同一种方式的类型。那么 ```new Salt()``` 是一个 Seasoning 吗？

> A : 是的。 ```new Salt()``` 是 Salt 的一个实例，每个 Salt 的实例都是一个 Seasoning。

---

> Q : ```new Pepper()``` 也是吗？

> A : 是的。它是一个 Seasoning。 ```new Pepper()``` 是 Pepper 的一个实例，每个 Pepper 的实例都是一个 Seasoning。

---

> Q : 什么是 abstract , class 和 extends 关键字？

> A : 简单地说：
abstract class 表示数据类型
class          表示变体
extends        表示连接变体到一个数据类型

---

> Q : 还有其他的 Seasoning 变体吗？

> A : 没有，因为只有 Salt 和 Pepper 继承 Seasoning。<br>
批注：两个 ```new Salt()``` 不是同一个变体值，在这里我们不展开讨论。 http://blog.csdn.net/zhshulin/article/details/50451521

---

> Q : 正确。只有 Salt 和 Pepper 是数据类型 Seasoning 的变体。但是，我们见过类似 Seasoning 数据类型吗？

> A : 没有。但是 boolean 类型有两个值：true 和 false。

---

> Q : 定义更多的 Seasoning 变体：
```
class Thyme extends Seasoning {}
```

> A : 还可以定义更多：
```
class Sage extends Seasoning {}
```


---

> Q : 现在有 4 个 Seasoning 的变体。

> A : 是的。

---

> Q : 什么是笛卡尔点？

> A : 它们是一对数。

---

> Q : 曼哈顿这个点位于哪里？

> A : An intersection where two city streets meet.

---

> Q : CartesianPt ManhattanPt 不同于 Salt 和 Pepper？
```
abstract class Point {}
```
```
class CartesianPt extends Point {
    int x;
    int y;
    CartesianPt（int _x, int _y）{
        x = _x;
        y = _y;
    }

}
```

```
class ManhattanPt extends Point {
    int x;
    int y;
    ManhattanPt（int _x, int _y）{
        x = _x;
        y = _y;
    }

}
```

> A : 两个类{}包含了三个元素。X/Y 是表示点的坐标，但是构造函数里面包含什么呢？（构造函数是同类名的函数）

---

> Q : 构造函数包含了各自对象相应的变量。

> A : 那怎么使用构造函数呢？

---

> Q : 构造函数作用于创建类新的实例。

> A : 这样子呀。

---

> Q : 比如我们使用 CartesianPt 的构造函数，创建一个 CartesianPt 实例：
```
new CartesianPt(2,3);
```

> A : 那么我们创建了一个 CartesianPt ，其 x 值为 2，y 值为 3。看下面代码：
```
class CartesianPt extends Point {
```
创建的 CartesianPt 也是 Point。

---

> Q : 是的。那么一个 ManhattanPt 实例呢？
```
new ManhattanPt(2,3);
```

> A : 它也有 x 值为 2，y 值为 3。

---

> Q : 构造函数都明白了？

> A : 基本上，但我们以前用过构造函数，但是没定义过他。这是怎么工作的呢?

---

> Q : 比如 Salt 和 Pepper，他们有个默认构造函数。

> A : 那我们使用默认构造函数正确吗？

---

> Q : 是的。默认构造函数没有包含变量，当我们使用 new 关键字创建实例时，不会创建任何类里面的变量对象。

> A : 是的，那 
``` 
new Point() 
```
是什么

--- 

> Q : 一个抽象类是不完整的，所以 new 关键字创建不出 Point 实例。

> A : 这就说得通了，继续。

---

> Q : 以下定义的类是另一种带变体的数据类型吗？
```
abstract class Num {}
```
```
class Zero extends Num {}
```
```
class OneMoreThan extends Num {
    Num predecessor;
    OneMoreThan (Num p) {
        predecessor = p;
    }
}
```

> A : 是的。它们定义了一种数据类型和两个变体。
图
---

> Q : new Zero() 是 Num 的实例吗？

> A : 明显是的。就像 new Salt() 是 Salt 的一个实例。

---

> Q : new OneMoreThan(new Zero()) 是 Num 的实例吗？

> A : 是。OneMoreThan 继承了 Num，new OneMoreThan() 是一个 OneMoreThan 实例，本身也是一个 Num 实例，并拥有了一个 Num 实例。 

---

> Q : 为什么 OneMoreThan 可以这样实现？

> A : new Zero() 是一个 Num 实例，OneMoreThan 的实例创建拥有了 Zero 的实例。

---

> Q : 拥有 Zero 实例？

> A : OneMoreThan 的实例拥有一个值叫做 predecessor，即这个值可以是 new Zero()。

---

> Q : 

> A :

---

> Q :

> A :

---

> Q :

> A :

---

> Q :

> A :

---

> Q :

> A :

---

> Q :

> A :

---

> Q :

> A :

---

> Q :

> A :