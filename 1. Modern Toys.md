## 一、现代的玩具 - Java 可以做很多事
一个 Q 与 A 的对话，展示了 Java 那些小事。 

> Q : 5 是整数吗?

> A : 是。

---

> Q : -23 是数吗?

> A : 是，但负数使用场景很少。

---

> Q : 5.32 是整数吗?

> A : 不是，我们不用这种数值类型表示 5.32 。

---

> Q : 5 属于什么数值类型?

> A : int 整型。
批注: int 整型是基本类型，int 整型代表整数。

---

> Q : 快，想出另一个整数！

> A : 19？

---

> Q : 那 true 属于什么数值类型？

> A : boolean 布尔型。

---

> Q : false 属于什么数值类型？

> A : boolean 布尔型。

---

> Q : 想得出其他布尔值吗？

> A : 没有，布尔值只有 true 和 false。

---

> Q : int 整型是什么？

> A : 一种类型。

---

> Q : boolean 布尔型是什么？

> A : 另一种类型。

---

> Q : 什么是类型？

> A : 类型是一个相关值集合的名称。

---

> Q : 能举例解释下类型吗？

> A : 使用类型就像使用一种集合一样。比如使用 boolean 布尔型可以表示逻辑值：是与非

---

> Q : 能创建新的类型吗？

> A : 我们还不知道怎么创建。

---

> Q : 画出下面类的必要关系特征。
```
abstract class Seasoning {}
```
```
class Salt extends Seasoning {}
```
```
class Pepper extends Seasoning {}
```
批注：Seasoning 是数据类型。
> A : 这样画？
![类关系图](https://github.com/JeffLi1993/a-little-java-a-few-pattern/blob/master/image/toys_00.png)

---

> Q : 是的。Seasoning 是数据类型，Salt 和 Pepper 是 Seasoning 的变体。

> A : 好的。三个类全部都是新类型吗？

---

> Q : 是的，同一种方式的类型。那么 ```new Salt()``` 是一个 Seasoning 吗？

> A : 是的。 ```new Salt()``` 是 Salt 的一个实例，每个 Salt 的实例都是一个 Seasoning。

---

> Q : ```new Pepper()``` 也是吗？

> A : 是的。它是一个 Seasoning。 ```new Pepper()``` 是 Pepper 的一个实例，每个 Pepper 的实例都是一个 Seasoning。

---

> Q : 什么是 abstract , class 和 extends 关键字？

> A : 简单地说：
abstract class 表示数据类型
class          表示变体
extends        表示连接变体到一个数据类型

---

> Q : 还有其他的 Seasoning 变体吗？

> A : 没有，因为只有 Salt 和 Pepper 继承 Seasoning。<br>
批注：两个 ```new Salt()``` 不是同一个变体值，在这里我们不展开讨论。 http://blog.csdn.net/zhshulin/article/details/50451521

---

> Q : 正确。只有 Salt 和 Pepper 是数据类型 Seasoning 的变体。但是，我们见过类似 Seasoning 数据类型吗？

> A : 没有。但是 boolean 类型有两个值：true 和 false。

---

> Q : 定义更多的 Seasoning 变体：
```
class Thyme extends Seasoning {}
```

> A : 还可以定义更多：
```
class Sage extends Seasoning {}
```


---

> Q : 现在有 4 个 Seasoning 的变体。

> A : 是的。

---

> Q : 什么是笛卡尔点？

> A : 它们是一对数。

---

> Q : 曼哈顿这个点位于哪里？

> A : An intersection where two city streets meet.

---

> Q : CartesianPt 类和 ManhattanPt 类不同于 Salt 类和 Pepper 类？

```
abstract class Point {}
class CartesianPt extends Point {
    int x;
    int y;
    CartesianPt（int _x, int _y）{
        x = _x;
        y = _y;
    }
}
class ManhattanPt extends Point {
    int x;
    int y;
    ManhattanPt（int _x, int _y）{
        x = _x;
        y = _y;
    }

}
```

> A : 两个类 {} 包含了三个元素。X、Y 是表示点的坐标，但是构造函数里面包含什么呢？（构造函数是同类名的函数）

---

> Q : 构造函数中，将传入的参数赋值了类的变量。

> A : 那怎么使用构造函数呢？

---

> Q : 构造函数作用于创建类新的实例。

> A : 这样子呀。

---

> Q : 比如我们使用 CartesianPt 的构造函数，创建一个 CartesianPt 实例：
```
new CartesianPt(2,3);
```

> A : 那么我们创建了一个 CartesianPt ，其 x 值为 2，y 值为 3。看下面代码：
```
class CartesianPt extends Point {
```
创建的 CartesianPt 也是 Point。

---

> Q : 是的。那么一个 ManhattanPt 实例呢？
```
new ManhattanPt(2,3);
```

> A : 它也有 x 值为 2，y 值为 3。

---

> Q : 构造函数都明白了？

> A : 基本上，但我们以前用过构造函数，但是没定义过他。这是怎么工作的呢?

---

> Q : 比如 Salt 和 Pepper，他们有个默认构造函数。

> A : 那我们使用默认构造函数正确吗？

---

> Q : 是的。默认构造函数没有包含变量，当我们使用 new 关键字创建实例时，不会创建任何类里面的变量对象。

> A : 是的，那 
``` 
new Point() 
```
是什么

--- 

> Q : 一个抽象类是不完整的，所以 new 关键字创建不出 Point 实例。

> A : 这就说得通了，继续。

---

> Q : 以下定义的类是另一种带变体的数据类型吗？
```
abstract class Num {}
```
```
class Zero extends Num {}
```
```
class OneMoreThan extends Num {
    Num predecessor;
    OneMoreThan (Num p) {
        predecessor = p;
    }
}
```

> A : 是的。它们定义了一种数据类型和两个变体。
图
---

> Q : new Zero() 是 Num 的实例吗？

> A : 明显是的。就像 new Salt() 是 Salt 的一个实例。

---

> Q : new OneMoreThan(new Zero()) 是 Num 的实例吗？

> A : 是。OneMoreThan 继承了 Num，new OneMoreThan() 是一个 OneMoreThan 实例，本身也是一个 Num 实例，并拥有了一个 Num 实例。 

---

> Q : 为什么 OneMoreThan 可以这样实现？

> A : new Zero() 是一个 Num 实例，OneMoreThan 的实例创建拥有了 Zero 的实例。

---

> Q : 拥有 Zero 实例？

> A : OneMoreThan 的实例拥有一个值叫做 predecessor，即这个值可以是 new Zero()。

---

> Q : predecessor 只能表示 Zero 的实例？

> A : 不是的。predecessor 的类型说明了 predecessor 表示 Num 的实例，所以可以表示 OneMoreThan 的实例或者 Zero 的实例。

---

> Q : 那 new OneMoreThan(new OneMoreThan(new Zero())）呢？

> A : 一个 Num 的实例，最外层的 new OneMoreThan 拥有了一个 Num 的实例：new OneMoreThan(new Zero())。

---

> Q : 那 new OneMoreThan(0)?

> A : 胡言乱语，Java 无法确定一个类型，0 不是一个 Num 类型的实例。

---

> Q : new Zero() 和 0 一样吗？

> A : 不一样，虽然它们概念差不多，但不一样。

---

> Q : new OneMoreThan(new Zero()) 和 1 概念差不多？

> A : 是的。

---

> Q :  new OneMoreThan(
            new OneMoreThan(
                new OneMoreThan(new Zero()))）和哪个数值概念差不多？

> A : 3

---

> Q : Num 数量比 boolean 类型数量多吗？

> A : 多很多。

---

> Q : 比 int 类型多吗？

> A : 不。

---

> Q : new Zero() 和 0 的区别呢？

> A : new Zero() 是一个 Zero 的一个实例，意味着也是一个 Num 的实例。0 是一个 int。我们得区别它们。

---

> Q : 正确。不同基本类型的实例就是不同的。

> A : 类型是一系列实例的统称。

---

> Q : 基本类型（int 和 boolean）是不同的。

> A : 那些不是基本类型呢？

---

> Q : 定义类型无法使基本类型，比如上面提到的 new Zero() 不单单是 Zero 的实例，也是 Num 的实例。任何继承 Num 的定义类型都是。

> A : 哦？

---

> Q : 就像每个类型都继承自 Object。

> A : 那么说所有都是一个对象， Object 的实例。

---

> Q : 正确，我们马上会看到体现。

> A : 好的。

---
建议一：
自定义类型时，使用抽象类
自定义子类型时，使用 extends 关键词继承抽象类
---

> Q : 看看下面的定义？
```
abstract class Layer {}
```
```
class Base extends Layer {\
    Object o;
    Base(Object o) {
        this.o = o;
    }
}
```
```
class Slice extends Layer {
    Layer l;
    Slice(Layer l) {
        this.l = l;
    }
}
```
> A : 定义了 Layer 类型和两个 Layer 子类型 Base 和 Slice。 Base 子类型拥有一个对象 Object。

---

> Q : new Base(new Zero()) 是什么？

> A : 一个 Base 的实例，即是 Layer 的实例又是 Object 的实例。

---

> Q : new Base(new Salt()) 是什么？

> A : 一个 Base 的实例。但 new Base(new Salt()) 和 new Base(new Zero()) 是一样的子类型吗？

---

> Q : 是的。因为 new 关键字创建的都是对象，而它们的类型都是 Base 类型。

> A : 因为 Base 拥有一个对象 Object。所以可以设置 Object 为 new Salt() 或 new Zero()。

---

> Q : 任何都是个 Object 吗？

> A : new 关键字创建的都是对象。自然 String 、Arrays 也是对象，这里我们不展开讲。

---

> Q : 是的。下面的是 Layer 实例吗？
```
new Base(5)
```

> A : 5 没有通过 new 创建，所以这个错误的语法。

---

> Q : 是的。下面的是 Layer 实例吗？
```
new Base(false)
```

> A : false 没有通过 new 创建，所以这个错误的语法。

---

> Q : 正确。下面的是 Layer 实例吗？
 ```
 new Base(new Integer(5))
```

> A : 是的。 new Integer 创建了一个 int 对象。

---

> Q : 那么怎么创建一个 Layer 实例拥有 false？

> A : 简单：
```
 new Base(new Boolean(false))
```

---

> Q : int Integer / boolean Boolean 概念很混乱？

> A : 以后会涉及到，资料：

---

> Q : 期待更多？

> A : 迫不及待。